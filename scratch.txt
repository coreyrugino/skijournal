<Modal
  isOpen={bool}
  onAfterOpen={afterOpenFn}
  onRequestClose={requestOpenFn}
  closeTimeoutMS={n}
  style={customStyle}
>
  <h1>Modal Content</h1>
  <p>Etc.</p>
</Modal>

can't require absolute file:
MENU
Home
SUBSCRIBE
MENU
Configuring Rails / Webpack / React environment
05 NOVEMBER 2015
Following my previous article I’m going to walk you through a basic Webpack - Rails -React integration.

Prepare your environment
First let’s create our sample rails application. We’ll call it webpack_rails_example.
At the moment Rails 4.2.4 is the current Rails version.
To use Webpack you’ll need to have Node.js and npm installed. npm is a JavaScript
package manager. You can find installation steps here.
After installing Node.js and npm go to the webpack_rails_example directory. Type
npm init to create package.json. You will be asked a few questions - you can go
with the defaults. It’s not important at this stage.

Configure webpack
First install Webpack with npm. While being in the root directory type npm install webpack --save-dev (--save-dev flag will automaticaly save Webpack as a dependency in package.json).

Webpack expects webpack.config.js as a configuration file. Let’s create it in our main directory. Populate the file with this:

path = require('path’);

module.expors = {
    context: __dirname + "/app/assets/javascripts”,
    entry: {
        "dist/index": [
            "./src/index.coffee"
        ]
    },
    output: {
        path: path.join(__dirname, "./app/assets/javascripts"),
    filename: "[name].js"
    }
}
That’s enough for now. Let’s quickly go through it.

context options sets the context(root) for our files. Thanks to this option you won’t have to repeat yourself with /app/assets/javascripts while specifying new entry points,
entry is definition of from where should webpack take source file and where should it put the compiled files (and what should be the name of the module). In this case our source will be app/assets/javascripts/src/index.coffee and the compilation will be put to app/assets/javascripts/dist/index.js.
output.path - this is an absolute path of the directory where our compilation should be put.
output.filename - this is the name of the output file. [name] will copy the name specified in the entry.
We are using path package here so we’ll need to install it first.
npm install path --save-dev

First run
Let’s try to run it. Typewebpack in your console.
You’ll probably get an error and this is because we installed Webpack as a local package and local packages are not in your path. But luckily npm comes to the rescue. Open package.json file and find scripts. This will probably look like this now:
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }.

You can run the specified script with npm run [script], and npm will know to look for executables in yout local node_modules folder (in case you didn’t notice installing npm packages created node_modules directory in the root project’s directory). Go ahead and create a new script. We’ll call it build.
build command will execute webpack --progress --profile --colors. Now your scripts should look like this:

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack --progress --profile --colors"
  }
You can remove test script if you want.
Try to run npm run build in your console to build assets.
Unfortunately you’ll get yet another error.

ERROR in multi dist/index.js
Module not found: Error: Cannot resolve 'file' or 'directory' ./src/index.coffee in /Users/bartekglowacki/Projects/tmp/webpack_rails_example/app/assets/javascripts
 @ multi dist/index.js
This means that we didn’t create app/assets/javascripts/src/index.coffee. Let’s do it now, and let’s populate it with:
console.log "Hello from console"

Try to run npm run build in your console again. Dang it! Yet another error.

ERROR in ./app/assets/javascripts/src/index.coffee
Module parse failed: /Users/bartekglowacki/Projects/tmp/webpack_rails_example/app/assets/javascripts/src/index.coffee Line 1: Unexpected string
You may need an appropriate loader to handle this file type.
| console.log "Hello from console"
 @ multi dist/index.js
Webpack doesn’t understand CoffeeScript and that’s what it tells you. No problem! We can use a Webpack loader to fix it. Loaders give Webpack ability to understand and properly transform the code. What you need now is CoffeeScript loader. Install it with npm npm install coffee-loader --save-dev.
Apart from installing the loader we need to tell Webpack where to use it. Open webpack.config.js file and just below output option add:

module: {
    loaders: [
      { test: /\.coffee$/, loader: "coffee" },
    ]
  }
This will tell webpack to use coffee loader on all files that name passes /\.coffee$/ test. After changing the configuration file run npm run build again.
Now everything should work as expected. Check app/assts/javascripts/dist directory to confirm if everything works. If yes, you’ll find index.js file inside.

Remember to add index.js to assets.rb and your application html. Add it at the end of the <body /> tag to avoid any errors.

Hooking up React
That should be easy now. You know everything you need to do.
Add React and jsx-loader to handle React views. Install both packages with npm.
npm install react react-dom jsx-loader --save-dev

Create hello_world_component.cjsx file in the src directory. This is where we'll create our first React component. The hello_world_component.cjsx component should look like this:

React = require('react')

HelloWorld = React.createClass
  render: ->
    `<div>Hello From React Component</div>`


module.exports = HelloWorld
Next let’s tell webpack what to do with .cjsx files
Add a loader definition which should look like this:
{ test: /\.cjsx/, loaders: ["jsx", "coffee"]} Loaders are applied from right to left so coffee loader will be applied as first.

Now go to the dist/index.coffee file and require both React and the component file, and try to render the component. The code should look like this:

React = require('react')
ReactDOM = require('react-dom')
HelloWorld = React.createFactory(require('./hello_world_component.cjsx'))

ReactDOM.render(HelloWorld(), document.body)
Run npm run build again and refresh the page. Assuming everything works you should see the Hello From React Component text on the web page.

Better webpack - webpack-dev-server
Running npm run build after every change gets a little tedious. Fortunately there is webpack-dev-server.

Go ahead and install it with npm install webpack-dev-server --save-dev.

For our convenience let’s create another script in package.json. We’ll call it dev-server, and it should look like this:
"dev-server": "webpack-dev-server --hot --inline --progress --colors”. What webpack-dev-server does is building the assets on the fly and servers them under the publicPath which you can specify in the webpack.config.js in the output option. Adjust your output configuration to look like this:

output: {
    path: path.join(__dirname, "./app/assets/javascripts"),
    filename: "[name].js",
    publicPath: "http://localhost:8080/assets"
  }
webpack-dev-server does not build your assets physically in the path you specified so you’ll need to adjust your environments/development.rb as well to allow rails read these assets from http://localhost:8080/assets. Open development.rb and add these few lines.

config.action_controller.asset_host = Proc.new { |source|
    if source =~ /^\/assets\/dist\/\w+\.js$/i
      "http://localhost:8080"
    end
  }
Restart your Rails server to apply the changes.

Basically this will tell Rails to take assets from our webpack-dev-server if the assets are requested from the /assets/dist directory.
Run webpack-dev-server with npm run dev-server. Go to localhost:3000 and check if everything works as it is expected.

If serving assets from webpack-dev-server does not work for you try to set config.assets.debug = false and config.assets.digest = false in the development.rb file

Hot Reloading (not live reload!)
The neat feature of webpack-dev-server together with React is Hot Module Replacement. This will update your javascript code without a need to refresh the page itself. It's even better than that because not only it does not refresh your page - it also does not touch the state of the component. It works great during new React component creation.
To make it work we’ll need react-hot-loader. Install it with npm and add it to webpack configuration file, so that the definition of .cjsx files looks like this:
{ test: /\.cjsx/, loaders: ["react-hot", "jsx", "coffee"]} Restart your webpack-dev-server and go to your React component, change it, and save the file. webpack-dev-server will automatically recompile the files and push the changes to your codebase.

That’s it! You are ready to go!

One last bit might be connecting rails s and webpack-dev-server with foreman, but because this article is quite long already I’ll let you figure it out on your own.


Bartek Głowacki
Read more posts by this author.

Poland, Wrocław
Share this post

Why we moved to from Asset Pipeline to Webpack
Recently we've started experimenting with moving our assets management from Asset Pipeline to Webpack. But why to go extra…
Ruby, Rails, DevOps © 2016Proudly published with Ghost

openModal() {
  this.setState({modalIsOpen: true});
}

closeModal() {
  this.setState({modalIsOpen: false});
}

handleModalCloseRequest() {
  // opportunity to validate something and keep the modal open even if it
  // requested to be closed
  this.setState({modalIsOpen: false});
}

handleInputChange() {
  this.setState({foo: 'bar'});
}

handleOnAfterOpenModal() {
  // when ready, we can access the available refs.
  this.refs.title.style.color = '#F00';
}


render(){
  return(
    <div>
      <div className='col s12 m4'>
        <div className='z-depth-5 card hoverable green' onClick={()=>this.openModal()} id='journalCards'>
          <div className='card-content white-text'>
            <span className='card-title'>{this.props.title}</span>
            <h3>{this.props.date}</h3>
            <p className='flow-text truncate'>{this.props.story}</p>
            <p>{this.props.partners}</p>
            <a href='#' className='black' onClick={()=>this.deleteItem()} >X</a>
          </div>
        </div>
      </div>
      <ReactModal
        ref="mymodal"
        closeTimeoutMS={150}
        isOpen={this.state.modalIsOpen}
        onAfterOpen={this.handleOnAfterOpenModal}
        onRequestClose={this.handleModalCloseRequest}>
        <h1 ref="title">Hello</h1>
        <button onClick={this.closeModal}>close</button>
        <div>I am a modal</div>
        <form>
          <input onChange={this.handleInputChange} />
          <input />
          <input />
          <input />
          <input />
          <br/>
          <button>hi</button>
          <button>hi</button>
          <button>hi</button>
          <button>hi</button>
        </form>
      </ReactModal>
    </div>);
}
}
www.kroger.com/recall

require "instagram"
   Instagram.configure do |config|
   config.client_id = 'a17fd3f59f49470f87d64b71613bd2f9'
   config.access_token = '13409763.a17fd3f.f05f1dbe234746b68df24c3664b9aef1'
end

https://api.instagram.com/v1/users/self/media/recent/?access_token=13409763.a17fd3f.f05f1dbe234746b68df24c3664b9aef1

http://api.dar.fm/playlist.php?q=@artist%black&partner_token=9388418650
// <h4 className='center-align'>{this.props.location.name}</h4>
// <p className='flow-text truncate'>{this.props.caption.story}</p>

/** @jsx React.DOM */

var ReactLayeredComponentMixin = {
    componentWillUnmount: function() {
        this._unrenderLayer();
        document.body.removeChild(this._target);
    },
    componentDidUpdate: function() {
        this._renderLayer();
    },
    componentDidMount: function() {
        // Appending to the body is easier than managing the z-index of everything on the page.
        // It's also better for accessibility and makes stacking a snap (since components will stack
        // in mount order).
        this._target = document.createElement('div');
        document.body.appendChild(this._target);
        this._renderLayer();
    },
    _renderLayer: function() {
        // By calling this method in componentDidMount() and componentDidUpdate(), you're effectively
        // creating a "wormhole" that funnels React's hierarchical updates through to a DOM node on an
        // entirely different part of the page.
        React.renderComponent(this.renderLayer(), this._target);
    },
    _unrenderLayer: function() {
        React.unmountComponentAtNode(this._target);
    }
};

var Modal = React.createClass({
    killClick: function(e) {
        // clicks on the content shouldn't close the modal
        e.stopPropagation();
    },
    handleBackdropClick: function() {
        // when you click the background, the user is requesting that the modal gets closed.
        // note that the modal has no say over whether it actually gets closed. the owner of the
        // modal owns the state. this just "asks" to be closed.
        this.props.onRequestClose();
    },
    render: function() {
        return this.transferPropsTo(
            <div className="ModalBackdrop" onClick={this.handleBackdropClick}>
                <div className="ModalContent" onClick={this.killClick}>
                    {this.props.children}
                </div>
            </div>
        );
    }
});

var ModalLink = React.createClass({
    mixins: [ReactLayeredComponentMixin],
    handleClick: function() {
        this.setState({shown: !this.state.shown});
    },
    getInitialState: function() {
        return {shown: false, ticks: 0, modalShown: false};
    },
    componentDidMount: function() {
        setInterval(this.tick, 1000);
    },
    tick: function() {
        this.setState({ticks: this.state.ticks + 1});
    },
    renderLayer: function() {
        if (!this.state.shown) {
            return <span />;
        }
        return (
            <Modal onRequestClose={this.handleClick}>
                <h1>Hello!</h1>
                Look at these sweet reactive updates: {this.state.ticks}
            </Modal>
        );
    },
    render: function() {
        return <a href="javascript:;" role="button" onClick={this.handleClick}>Click to toggle modal</a>;
    }
});

React.renderComponent(<ModalLink />, document.body);
